{"ast":null,"code":"import title from \"title\";\n\nfunction convertToHierarchy(r, paths\n/* array of array of strings */\n) {\n  // Build the node structure\n  const rootNode = {\n    name: \"root\",\n    path: \"\",\n    children: [],\n    level: 0\n  };\n\n  for (let path of paths) {\n    buildNodeRecursive(r, rootNode, path.substring(2).split(\"/\"), 0);\n  }\n\n  return rootNode;\n}\n\nfunction buildNodeRecursive(r, node, path, idx) {\n  if (idx < path.length) {\n    let fullPath = \"./\" + path.slice(0, idx + 1).join(\"/\");\n    const metaKey = fullPath.slice(0, fullPath.lastIndexOf(\"/\"));\n    const dirMetaKey = metaKey.slice(0, metaKey.lastIndexOf(\"/\"));\n    const meta = typeof metaMap[metaKey] !== \"undefined\" ? metaMap[metaKey] : {};\n    let item = path[idx];\n    let name = item.replace(/\\.(mdx?|jsx?)$/, \"\");\n    let dir = node.children.find(child => child.name == item);\n\n    if (!dir) {\n      const mdxModule = /\\.(mdx?|jsx?)$/.test(item) ? r(fullPath) : undefined;\n      const itemMeta = normalizeMeta(meta[name], name, mdxModule ? mdxModule.frontMatter : {});\n      console.log(mdxModule ? mdxModule : \"\");\n\n      if (!/index\\.(mdx?|jsx?)$/.test(item)) {\n        node.children.push(dir = {\n          level: idx + 1,\n          name: name,\n          path: fullPath.slice(2).replace(/\\.(mdx?|jsx?)$/, \"\").replace(/^\\d+\\_/, \"\"),\n          component: mdxModule ? mdxModule.default : mdxModule,\n          headings: mdxModule ? mdxModule.headings : mdxModule,\n          meta: itemMeta,\n          children: []\n        });\n      } else {\n        console.log(mdxModule.default);\n        node.component = mdxModule ? mdxModule.default : mdxModule;\n        node.headings = mdxModule ? mdxModule.headings : mdxModule;\n        node.meta = mdxModule ? mdxModule.frontMatter : {};\n      }\n\n      node.children.sort((a, b) => {\n        // sorting every time, need better sort\n        if (meta) {\n          return Object.keys(meta).indexOf(a.name) - Object.keys(meta).indexOf(b.name);\n        } // by default, we put directories first\n\n\n        if (!!a.children !== !!b.children) {\n          return !!a.children ? -1 : 1;\n        } // sort by file name\n\n\n        return a.name < b.name ? -1 : 1;\n      });\n    }\n\n    buildNodeRecursive(r, dir, path, idx + 1);\n  }\n}\n\nfunction normalizeMeta(meta, seg, frontMatter) {\n  return Object.assign(typeof meta !== \"undefined\" ? typeof meta === \"string\" ? {\n    title: meta\n  } : meta : {\n    title: title(seg.replace(/-/g, \" \"))\n  }, frontMatter);\n} // watch all meta files\n\n\nconst metaMap = {};\n\nfunction importAllMeta(r) {\n  return r.keys().forEach(key => {\n    metaMap[key.slice(0, key.lastIndexOf(\"/\"))] = r(key);\n  });\n} // watch all module files\n\n\nfunction importAllModules(r) {\n  const Hierarchy = convertToHierarchy(r, r.keys()); //  console.log(util.inspect(Hierarchy, {depth: null}))\n\n  return Hierarchy;\n}\n\nimportAllMeta(require.context(\"./pages/\", true, /meta\\.json$/));\nconst items = importAllModules(require.context(\"./pages/\", true, /\\.(mdx?|jsx?)$/));\nexport default (() => {\n  return items;\n});","map":{"version":3,"sources":["/sandbox/src/directories.js"],"names":["title","convertToHierarchy","r","paths","rootNode","name","path","children","level","buildNodeRecursive","substring","split","node","idx","length","fullPath","slice","join","metaKey","lastIndexOf","dirMetaKey","meta","metaMap","item","replace","dir","find","child","mdxModule","test","undefined","itemMeta","normalizeMeta","frontMatter","console","log","push","component","default","headings","sort","a","b","Object","keys","indexOf","seg","assign","importAllMeta","forEach","key","importAllModules","Hierarchy","require","context","items"],"mappings":"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","sourcesContent":["import title from \"title\";\n\nfunction convertToHierarchy(r, paths /* array of array of strings */) {\n  // Build the node structure\n  const rootNode = { name: \"root\", path: \"\", children: [], level: 0 };\n\n  for (let path of paths) {\n    buildNodeRecursive(r, rootNode, path.substring(2).split(\"/\"), 0);\n  }\n\n  return rootNode;\n}\n\nfunction buildNodeRecursive(r, node, path, idx) {\n  if (idx < path.length) {\n    let fullPath = \"./\" + path.slice(0, idx + 1).join(\"/\");\n    const metaKey = fullPath.slice(0, fullPath.lastIndexOf(\"/\"));\n    const dirMetaKey = metaKey.slice(0, metaKey.lastIndexOf(\"/\"));\n\n    const meta =\n      typeof metaMap[metaKey] !== \"undefined\" ? metaMap[metaKey] : {};\n    let item = path[idx];\n    let name = item.replace(/\\.(mdx?|jsx?)$/, \"\");\n    let dir = node.children.find((child) => child.name == item);\n    if (!dir) {\n      const mdxModule = /\\.(mdx?|jsx?)$/.test(item) ? r(fullPath) : undefined;\n      const itemMeta = normalizeMeta(\n        meta[name],\n        name,\n        mdxModule ? mdxModule.frontMatter : {}\n      );\n      console.log(mdxModule ? mdxModule : \"\");\n\n      if (!/index\\.(mdx?|jsx?)$/.test(item)) {\n        node.children.push(\n          (dir = {\n            level: idx + 1,\n            name: name,\n            path: fullPath\n              .slice(2)\n              .replace(/\\.(mdx?|jsx?)$/, \"\")\n              .replace(/^\\d+\\_/, \"\"),\n            component: mdxModule ? mdxModule.default : mdxModule,\n            headings: mdxModule ? mdxModule.headings : mdxModule,\n            meta: itemMeta,\n            children: []\n          })\n        );\n      } else {\n        console.log(mdxModule.default);\n        node.component = mdxModule ? mdxModule.default : mdxModule;\n        node.headings = mdxModule ? mdxModule.headings : mdxModule;\n        node.meta = mdxModule ? mdxModule.frontMatter : {};\n      }\n      node.children.sort((a, b) => {\n        // sorting every time, need better sort\n        if (meta) {\n          return (\n            Object.keys(meta).indexOf(a.name) -\n            Object.keys(meta).indexOf(b.name)\n          );\n        }\n        // by default, we put directories first\n        if (!!a.children !== !!b.children) {\n          return !!a.children ? -1 : 1;\n        }\n        // sort by file name\n        return a.name < b.name ? -1 : 1;\n      });\n    }\n    buildNodeRecursive(r, dir, path, idx + 1);\n  }\n}\n\nfunction normalizeMeta(meta, seg, frontMatter) {\n  return Object.assign(\n    typeof meta !== \"undefined\"\n      ? typeof meta === \"string\"\n        ? { title: meta }\n        : meta\n      : { title: title(seg.replace(/-/g, \" \")) },\n    frontMatter\n  );\n}\n// watch all meta files\nconst metaMap = {};\nfunction importAllMeta(r) {\n  return r.keys().forEach((key) => {\n    metaMap[key.slice(0, key.lastIndexOf(\"/\"))] = r(key);\n  });\n}\n\n// watch all module files\n\nfunction importAllModules(r) {\n  const Hierarchy = convertToHierarchy(r, r.keys());\n  //  console.log(util.inspect(Hierarchy, {depth: null}))\n  return Hierarchy;\n}\n\nimportAllMeta(require.context(\"./pages/\", true, /meta\\.json$/));\n\nconst items = importAllModules(\n  require.context(\"./pages/\", true, /\\.(mdx?|jsx?)$/)\n);\n\nexport default () => {\n  return items;\n};\n"]},"metadata":{},"sourceType":"module"}